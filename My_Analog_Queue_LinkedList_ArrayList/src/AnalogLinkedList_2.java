public class AnalogLinkedList_2<T> {
    private int size; //обьявляем скрытое поле класса типа int - буфер для хранения данных информирующий нас о размере
    // двусвязного списка (инициализация по умолчанию = 0) c соответствующим именем
    private Node<T> firstNode; //обьявляем скрытое поле класса типа класса Node<Generics> - первыйУзел (инициализация
    // по умолчанию = null)
    private Node<T> lastNode; //обьявляем скрытое поле класса типа класса Node<Generics> - последнийУзел (инициализация
    // по умолчанию = null)

    private static class Node<T> { //создаем класс обьектов Узел для нашего двусвязного списка
        Node<T> previous; //ссылка на предидущий узел
        T elementData; //данные элемента, которые хранятся в Узле
        Node<T> next; //ссылка на следующий узел

        public Node(Node<T> previous, T elementData, Node<T> next) { //конструктор инициализации Узлов
            this.previous = previous; //инициализируем поле класса
            this.elementData = elementData; //инициализируем поле класса
            this.next = next; //инициализируем поле класса
        }
    }
    private void checkElementIndex(int index) { //метод для проверки корректности индекса элемента списка
        if (!isElementIndex(index)) { //если за пределами допустимого, то
            throw new IndexOutOfBoundsException("Index: " + index + "; Size: " + this.size); //бросить новое исключение
            //класса ИсключениеИндексаЗаПределыГраниц(с коминтарием)
        }
    }
    private boolean isElementIndex(int index) { //флаг для проверки корректности индекса элемента списка
        return index >= 0 && index < size; //возвращает true если условие выполняется
    }

    private Node<T> nodeSearch(int index) { //поиск Узла по индексу
        checkElementIndex(index); //проверяем на корректность индекс (чтоб не выходил за пределы границ)

        //чтоб не проходить по всему списку от начала до конца, используем двоичный (бинарный, дихотомический) поиск
        //с помощью "побитового сдвига вправо" (аппаратно команды сдвига = 2 машин.циклам, а умножение и деление = 4 машин.циклам
        //на 1 знак делим список пополам
        if (index < (size >> 1)) { //находим первую половину с начала списка (левая сторона)
            Node<T> nodeSearchElement = this.firstNode; //создаем ссылку типа класса Узел = ссылке на первый Узел из
            // инициализированного списка
            for (int i = 0; i < index; i++) { //проходим по данной половине списка по возрастанию
                nodeSearchElement = nodeSearchElement.next; //присваиваем ссылке на первый Узел ссылку на следующий Узел
            }
            return nodeSearchElement; //возвращаем искомый Узел по индексу
        } else { //находим вторую половину с конца списка (правая половина)
            Node<T> nodeSearchElement = this.lastNode; //создаем ссылку типа класса Узел = ссылке на последний Узел из
            // инициализированного списка
            for (int i = size - 1; i > index; i--) { //проходим по данной половине по убыванию
                nodeSearchElement = nodeSearchElement.previous; //присваиваем ссылке на первый Узел ссылку на предидущий Узел
            }
            return nodeSearchElement;//возвращаем искомый Узел по индексу
        }
    }

    public T get(int index) {
        return this.nodeSearch(index).elementData; //находим узел в соответствии с индексом и через оператор доступа(точка)
        //возвращаем значение(данные) Узла
    }

    public void addFirst(T object) {
        Node<T> nodeBuffer = new Node<>(null, object, null); //создали новый обьект Узел для хранения данных
        //элемента (с нулевыми ссылками на предидущий и следующий Узлы)
        if (this.size == 0) { //добавляем первый(по списку) Узел в пустой список и назначаем его первым и последним Узлом
            this.firstNode = nodeBuffer;
            this.lastNode = nodeBuffer;
            size++; //изменили размер списка с 0 на 1
        } else { //добавляем новый элемент в начало НЕпустого списка
            this.firstNode.previous = nodeBuffer; //ссылке первого Узла на предидущий Узел присваиваем значение =
            //значению нового обьекта Узел(который мы добавляем)
            nodeBuffer.next = this.firstNode; //ссылке добавляемого Узла на следующий Узел присваиваем значение =
            //Узлу, который до добавления был первым
            this.firstNode = nodeBuffer; //теперь первому Узлу (до добавления) присваиваем значение = значению
            // добавляемого Узла
            size++;// увеличиваем размер списка на 1
        }
    }

    public void addLast(T object) {
        Node<T> nodeBuffer = new Node<>(null, object, null); //создали новый обьект Узел для хранения данных
        //элемента (с нулевыми ссылками на предидущий и следующий Узлы)
        //добавление последнего(по списку) Узла в пустой список аналогично методу addFirst(T object)
        if (this.size == 0) { //если размер двусвязного списка = 0, то
            this.addFirst(object); //вызываем метод добавитьПервыйЭлемент(аргумент конструктора: ссылка-параметр метода
            // на дженерик)
        } else { //иначе
            this.lastNode.next = nodeBuffer; //ссылке последнего Узла на следующий Узел присваиваем значение =
            nodeBuffer.previous = this.lastNode; //ссылке добавляемого Узла на предидущий Узел присваиваем значение =
            // значению Узла, который до добавления был последним
            this.lastNode = nodeBuffer; //теперь последнему Узлу (до добавления) присваиваем значение = значению
            // добавляемого Узла
            size++; //увеличиваем размер списка на 1
        }
    }

    public boolean add(T object) { //метод по добавлению элемента в двусвязный список
        this.addLast(object); // двусвязный список всегда подразумевает добавление нового элемента в конец списка
        return true; //вернуть истина
    }

    public void removeFirst() { //метод удаления первого Узла связного списка
        Node<T> deleteFirstNode = this.firstNode; //создаем обьект Узла, кот. указывает на первый Узел
        this.firstNode = deleteFirstNode.next; //первый обьект Узла связного списка указывает на последующий Узел, кот.
        //займет его место и станет первым Узлом
        this.firstNode.previous = null; //предидущее значение первого Узла устанавливаем в ноль
        deleteFirstNode.next = null; //указатель обьекта первоначального Узла на следующий узел устанавливаем в ноль
        deleteFirstNode.elementData = null; //данные обьекта первоначального Узла указывающего на первый Узел
        // устанавливаем в ноль
        size--; //уменьшаем размер списка на -1
    }

    public void removeLast() { //метод удаления последнего Узла связного списка
        Node<T> deleteLastNode = this.lastNode;//создаем обьект Узла, кот. указывает на последний Узел
        this.lastNode = deleteLastNode.previous; //последний обьект Узла связного списка указывает на предидущий Узел, кот.
        //займет его место и станет последним Узлом
        this.lastNode.next = null; //последующее значение первого Узла устанавливаем в ноль
        deleteLastNode.previous = null; //указатель обьекта первоначального Узла на предидущий узел устанавливаем в ноль
        deleteLastNode.elementData = null; //данные обьекта первоначального Узла указывающего на последний Узел
        // устанавливаем в ноль
        size--; //уменьшаем размер списка на -1
    }

    public void remove(int index){ //метод удаления элемента из двусвязного списка по индексу элемента
        checkElementIndex(index); //проверяем на корректность индекс (чтоб не выходил за пределы границ)

        if (index == 0) { //если Узел под индексом 0, то
            this.removeFirst(); //вызываем метод удалитьПервыйЭлемент()
        } else if (index == (this.size - 1)) { //иначе если Узел под последним(по порядку) индексом, то
            this.removeLast(); //вызываем метод удалитьПоследнийЭлемент()
        } else { //иначе
            Node<T> deleteNode = this.nodeSearch(index); //создаем обьект Узла = Узлу по нужному нам индексу
            deleteNode.previous.next = deleteNode.next; //находим прямого предшественника, кот. указывает на приемника
            deleteNode.next.previous = deleteNode.previous; //находим прямого приемника, кот. указывает на предшественника
            deleteNode.previous = null; //обнуляем ссылку удаляемого Узла на предидущий Узел по нужному нам индексу
            deleteNode.elementData = null; //обнуляем ссылку на данные удаляемого Узла
            deleteNode.next = null; //обнуляем ссылку удаляемого Узла на последующий Узел по нужному нам индексу
            this.size--; //уменьшаем размер двусвязного списка на -1
        }
    }

    public void  print() { //метод для печати содержимого двусвязного списка
        for (int i = 0; i < size; i++) { //циклом проходим по списку по возрастанию
            System.out.println(this.get(i));//выводим на печать с помощью метода получитьЭлемент() каждый элемент списка
        }
    }

    public boolean contains(T element) { //метод для сравнения содержимого
        for (int i = 0; i < size; i++) { //циклом проходим по списку по возрастанию
            if (get(i).equals(element)) { //если полученный элемент из списка будет равен искомому элементу, то
                return true; //вернуть истина
            }
        }
        return false; //вернуть ложь
    }
}